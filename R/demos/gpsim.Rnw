% Run this file from R using Sweave("tp63.Rnw")
\documentclass[a4paper]{article}
\usepackage{url}
\usepackage[authoryear,round]{natbib}

\title{GPSIM User Guide}
\author{Antti Honkela, Pei Gao, Jonatan Ropponen, \\
  Neil D. Lawrence, and Magnus Rattray}

\newcommand{\Rfunction}[1]{{\texttt{#1}}}
\newcommand{\Robject}[1]{{\texttt{#1}}}
\newcommand{\Rpackage}[1]{{\textit{#1}}}
\newcommand{\gpsim}{\Rpackage{gpsim}}

\begin{document}
\maketitle
\SweaveOpts{keep.source=TRUE}

\section{Abstract}

The \gpsim{} package implements our methodology of Gaussian process
differential equation models for analysis of gene expression time
series from single input motif networks.  The package can be used for
inferring unobserved transcription factor (TF) protein concentrations
from expression measurements of known target genes, or for ranking
candidate targets of a TF.

\section{Citing \gpsim{}}

The \gpsim{} package is based on a body of methodological research.
Citing \gpsim{} in publications will usually involve citing one or more
of the methodology papers \citep{Gao2008,Honkela2010PNAS} that the
software is based on as well as citing the software package itself.

<<echo=FALSE, eval=TRUE>>=
options(width = 60)
@

\section{Introductory example analysis - Drosophila development}
\label{section:Introductory example}

In this section we introduce the main functions of the \Rpackage{puma}
package by repeating some of the analysis from the PNAS
paper~\citep{Honkela2010PNAS}\footnote{Note that the results reported
  in the paper were run using an earlier version of this package for
  MATLAB, so there can be minor differences.}.

\subsection{Installing the \gpsim{} package}

% The recommended way to install \gpsim{} is to use the
% \Rfunction{biocLite} function available from the bioconductor
% website. Installing in this way shoul d ensure that all appropriate
% dependencies are met.

% << eval=FALSE >>==
% source("http://www.bioconductor.org/biocLite.R")
% biocLite("gpsim")
% @

To install the gpsim software, unpack the software and run
\begin{verbatim}
R CMD INSTALL gpsim-0.9
\end{verbatim}

<<echo=FALSE>>=
library(gpsim, lib.loc='~/R-public')
@ 

\subsection{Loading the data}

To get started, you need some preprocessed time series expression
data.  If the data originates from Affymetrix arrays, we highly
recommend processing it with \Rfunction{mmgmos} from the
\Rpackage{puma} package.  This processing extracts error bars on the
expression measurements directly from the array data to allow judging
the reliability of individual measurements.  This information is
directly utilised by all the models in this package.

To start from scratch on Affymetrix data, the .CEL files from
\url{ftp://ftp.fruitfly.org/pub/embryo_tc_array_data/} may be
processed using:
<<eval=FALSE>>=
expfiles <- paste(rep(paste("embryo_tc", 2*2:4, sep="_"),
                      each=12), "_", 1:12, ".CEL", sep="")
expdata <- ReadAffy(filenames=expfiles,
                    celfile.path="embryo_tc_array_data")
pData(expdata) <- data.frame("time.h" = rep(1:12, 3),
                             row.names=rownames(pData(expdata)))
drosophila_mmgmos_exprs <- mmgmos(expdata)
drosophila_mmgmos_fragment <- drosophila_mmgmos_exprs
@ 

This data needs to be further processed to make it suitable for our
models.  This can be done using
<<eval=FALSE>>=
drosophila_gpsim_fragment <-
  processData(drosophila_mmgmos_fragment,
              experiments=rep(1:3, each=12))
@ 

In order to save time with the demos, a part of the result of this is
included in this package and can be loaded using
<<>>=
data(drosophila_gpsim_fragment)
@ 

\subsection{Learning individual models}

Here the last argument specifies that we have three independent time
series of measurements.

Let us now recreate some the models shown in the plots of the PNAS
paper~\citep{Honkela2010PNAS}:
<<>>=
targets <- c('FBgn0003486', 'FBgn0033188', 'FBgn0035257')

library(annotate)
aliasMapping <- getAnnMap("ALIAS2PROBE",
                  annotation(drosophila_gpsim_fragment))
twi <- get('twi', env=aliasMapping)
fbgnMapping <- getAnnMap("FLYBASE2PROBE",
                 annotation(drosophila_gpsim_fragment))
targetProbes <- mget(targets, env=fbgnMapping)

st_models <- list()
for (i in seq(along=targetProbes)) {
  st_models[[i]] <- GPLearn(drosophila_gpsim_fragment,
                            TF=twi, targets=targetProbes[i],
                            useGpdisim=TRUE, quiet=TRUE)
}
mt_model <- GPLearn(drosophila_gpsim_fragment, TF=twi,
                    targets=targetProbes,
                    useGpdisim=TRUE, quiet=TRUE)
show(mt_model)
@ 

\subsection{Visualising the models}

The models can be plotted using commands like
<<eval=FALSE>>=
GPPlot(st_models[[1]], nameMapping=getAnnMap("FLYBASE",
                         annotation(drosophila_gpsim_fragment)))
GPPlot(mt_model, nameMapping=getAnnMap("FLYBASE",
                   annotation(drosophila_gpsim_fragment)))
@ 

\begin{figure}
  \begin{center}
<<fig=TRUE, echo=FALSE>>=
GPPlot(st_models[[1]], nameMapping=getAnnMap("FLYBASE",
                         annotation(drosophila_gpsim_fragment)))
@
\end{center}
\caption{Single target models for the gene FBgn0003486. The models for
  each repeated time series are shown in different columns.}
\end{figure}

\begin{figure}
  \begin{center}
<<fig=TRUE, echo=FALSE>>=
GPPlot(mt_model, nameMapping=getAnnMap("FLYBASE",
                   annotation(drosophila_gpsim_fragment)))
@
\end{center}
\caption{Multiple-target model for all the example genes.  The
  call creates independent figures for each repeated time series.}
\end{figure}

\subsection{Ranking the targets}

Bulk ranking of candidate targets can be accomplished using
<<>>=
## Rank the targets, filtering weakly expressed genes with average
## expression z-score below 1.8
scores <- GPRankTargets(drosophila_gpsim_fragment, TF=twi,
                        testTargets=targetProbes,
                        options=list(quiet=TRUE),
                        filterLimit=1.8)
## Sort the returned list according to log-likelihood
scores <- sort(scores, descend=TRUE)
loglikelihoods(scores)
@ 

To save space, \Rfunction{GPRankTargets} does not return the models by
default.  If those are needed later e.g. for plotting, they can be
recreated using the inferred parameters saved together with the
ranking using
<<>>=
topmodel <- generateModels(drosophila_gpsim_fragment,
                           scores[1])
show(topmodel)
@ 

\subsection{Ranking using known targets with multiple-target models}

Ranking using known targets with multiple-target models can be
accomplished simply by adding the \texttt{knownTargets} argument
<<>>=
## Rank the targets, filtering weakly expressed genes with average
## expression z-score below 1.8
scores <- GPRankTargets(drosophila_gpsim_fragment, TF=twi,
                        knownTargets=targetProbes[1],
                        testTargets=targetProbes[2:3],
                        options=list(quiet=TRUE),
                        filterLimit=1.8)
## Sort the returned list according to log-likelihood
scores <- sort(scores, descend=TRUE)
loglikelihoods(scores)
@ 

\subsection{Running ranking in a batch environment}

\Rfunction{GPRankTargets} can be easily run in a batch environment
using the argument \texttt{scoreSaveFile}.  This indicates a file to
which scores are saved after processing each gene.  Thus one could,
for example, split the data to, say, 3 separate blocks according to
the reminder after division by 3 and run each of these independently.
The first for loop could then be run in parallel (e.g. as separate
jobs on a cluster), as each step is independent of the others.  After
these have all completed, the latter loop could be used to gather the
results.
<<eval=FALSE>>=
for (i in seq(1, 3)) {
  targetIndices <- seq(i,
    length(featureNames(drosophila_gpsim_fragment)), by=3)
  outfile <- paste('ranking_results_', i, '.Rdata', sep='')
  scores <- GPrankTargets(preprocData, TF=twi,
                          testTargets=targetIndices,
                          scoreSaveFile=outfile)
}

for (i in seq(1, 3)) {
  outfile <- paste('ranking_results_', i, '.Rdata', sep='')
  load(outfile)
  if (i==1)
    scores <- scoreList
  else
    scores <- c(scores, scoreList)
}
show(scores)
@ 

\section{Using non-Affymetrix data}

Using non-Affymetrix data, or data without associated uncertainty
information for the expression data in general, requires more because
of two reasons
\begin{itemize}
\item noise variances need to be estimated together with other model
  parameters; and
\item weakly expressed genes cannot be easily filtered \emph{a
    priori}.
\end{itemize}

The first of these is automatically taken care of by all the above
functions, but the latter requires some extra steps after fitting the
models.

In order to get started, you need to create an
\Rfunction{ExpressionTimeSeries} object of your data set.  This can be
accomplished with the function
<<eval=FALSE>>=
procData <- processRawData(data, times=c(...),
                           experiments=c(...))
@ 

\bibliographystyle{plainnat}
\bibliography{gpsim}

\end{document}
